# Configuracoes do banco de dados
#spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
#spring.datasource.username=${DB_USER}
#spring.datasource.password=${DB_PASSWORD}
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres
spring.datasource.username=admin
spring.datasource.password=123456

# Configuracoes do Hibernate
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.generate-ddl=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.show-sql=true
# IMPORTANTE - se true, implica que o mecanismo "Open Session in View" est\u00e1 ativado, permitindo que o contexto de 
# persist\u00eancia do Hibernate seja mantido aberto durante o processamento das visualiza\u00e7\u00f5es. \u00c9 mais recomend\u00e1vel 
# adotar uma abordagem mais expl\u00edcita para o carregamento de entidades relacionadas apenas quando necess\u00e1rio, usando, 
# por exemplo, o padr\u00e3o DTO ou Eager/Lazy Fetching.
spring.jpa.open-in-view=false
loggin.level.org.hibernate.SQL=DEBUG

# Configuracoes da aplicacao
server.error.include-stacktrace=on_param
#server.port=${PORT}
server.port=8081

# Servi\u00e7o de e-mail
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=personnimoveis@gmail.com
spring.mail.password=nzszgltxuasaauok
spring.mail.properties.mail.smtp.auth=true
# STARTTLS criptografa a comunica\u00e7\u00e3o entre o cliente (nossa aplica\u00e7\u00e3o) e o servidor de e-mails (gmail), protegendo os dados durante o transporte.
spring.mail.properties.mail.smtp.starttls.enable=true
# Tempo m\u00e1ximo que o cliente aguardar\u00e1 por uma resposta do servidor de e-mail durante tempo de conex\u00e3o e tempo de escrita: 5s.
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=5000
spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory